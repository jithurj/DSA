# -*- coding: utf-8 -*-
"""Arrays_DSA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vjDFtUQpf8xer3IYwkMCS8psUmU5eCZu
"""

from typing import List

"""** Check If N and Its Double **
Given an array arr of integers, check if there exist two indices i and j such that :
<br>
i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
 <br>
Example 1:

Input: arr = [10,2,5,3]
Output: true
Explanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]
<br>
Example 2:

Input: arr = [3,1,7,11]
Output: false
Explanation: There is no i and j that satisfy the conditions.
"""

class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        for i in range(len(arr)):
            for j in range(len(arr)):
                if i!=j and arr[i]==2*arr[j]:
                    return True
        return False
class Solution2:
    def checkIfExist(self, arr: List[int]) -> bool:
        seen= set()
        for i in arr:
            if i*2 in seen or i/2 in seen:
                return True
            seen.add(i)
        return False

""" **Valid Mountain Array**<br>

 Given an array of integers arr, return true if and only if it is a valid mountain array.
<br>
Recall that arr is a mountain array if and only if:

arr.length >= 3<br>
There exists some i with 0 < i < arr.length - 1 such that:<br>
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]<br>
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]


"""

class ValidMountainSolution:
    def validMountainArray(self, arr: List[int]) -> bool:
        n=len(arr)
        climb=0
        #find peak by climbing till conditions are met
        while climb < n-1 and arr[climb] <arr[climb+1]:
            climb+=1
        #peak cannot be first or last element
        if climb== 0 or climb==n-1:
            return False
        #climb down till last element while conditions are met
        while climb <n-1 and arr[climb] > arr[climb+1]:
            climb+=1
        #if last element reached it is a montain array
        if climb== n-1:
             return True
        else:
            return False

class ValidMountainSolution2:
    def validMountainArray(self, arr: List[int]) -> bool:
        n=len(arr)
        if n < 3: return False;
        left_climb=0
        right_climb=n-1
        #climbing from both sides and checking if the peak is same from both sides and peak cannot be first or last element
        while left_climb<n-1 and arr[left_climb]<arr[left_climb+1]:
            left_climb+=1
        while right_climb>0 and arr[right_climb-1]>arr[right_climb]:
            right_climb-=1
        if left_climb==right_climb and left_climb>0 and right_climb<n-1:
            return True
        else:
            return False

"""**Replace Elements with Greatest Element on Right Side** <br>
Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.<br>
Input: arr = [17,18,5,4,6,1]<br>
Output: [18,6,6,6,1,-1]

"""

class GreatElementRightSolution:
    def replaceElements(self, arr: List[int]) -> List[int]:
      """
  The idea is to start from the rightmost element, move to the left side one by one, and keep track of the maximum element.
  Replace every element with the maximum element.
  Time Complexity: O(n) where n is the number of elements in array.
  Auxiliary Space: O(1)
      """
      n=len(arr)
      max_right= arr[n-1]
      arr[n-1]= -1
      for i in range(n-2,-1,-1):
          temp=arr[i]
          arr[i]=max_right
          if  temp>max_right:
              max_right=temp

      return arr

    def replaceElements2(self, arr: List[int]) -> List[int]:
          mx = -1
          for i in range(len(arr) - 1, -1, -1):
              arr[i], mx = mx, max(arr[i], mx)
          return arr

"""**Duplicates from Sorted Array**<br>
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.<br>

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:<br>

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.
"""

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        j=1
        for i in range(len(nums)-1):
            if nums[i]!=nums[i+1]:
                nums[j]=nums[i+1]
                j+=1
        return j

a=[1,10,3,4,5,6]
a[0],a[1]=a[1],a[0]
x=sorted(a)
print(a,x)

"""**Move Zeroes**<br>

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.<br>

Note that you must do this in-place without making a copy of the array.
"""

class MoveZeroSolution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        use 0 as a pivot element and whenever we see a non zero element,
        we will swap it with the pivot element. So all the non zero element
        will come at the beginning        """
        j=0
        for i in range(len(nums)):
            if nums[i]!=0:
                nums[j],nums[i]= nums[i],nums[j]
                j+=1

"""**Sort Array By Parity**

> Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.


> Return any array that satisfies this condition.
"""

class SortParitySolution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        j=0
        for i in range(len(nums)):
            if nums[i]%2==0:
                nums[i],nums[j]=nums[j],nums[i]
                j+=1
        return nums

"""**Remove Element**<br>


Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.<br>

Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.<br>
Return k.
"""

class RemoveElementSolution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0
        for i in nums:
            if i!= val:
                nums[k]=i
                k+=1

        return k

""" **Find All Numbers Disappeared in an Array** <br>
Given an array nums of n integers where nums[i] is in the range [1, n], <br>
return an array of all the integers in the range [1, n] that do not appear in nums.
"""

class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
      """
      The idea is to use the original array to keep track of the numbers visited.
      Since all the numbers are positive intergers,
      for every number visited we mark the presence of that number by negating the number at the index equal to the current number.
      Since Python follows 0-indexing, the index we mark is actually number - 1.
      If the number at that index is already negated we do nothing.
      In the end, we just return the indices (index + 1 for the number) where there are still postive numbers
      """
        for item in range(len(nums)):
            temp_v= abs(nums[item])-1
            if nums[temp_v]>0:
                nums[temp_v]*=-1
        out=[]
        for index,item in enumerate(nums):
            if item >0:
                out.append(index+1)
        return out

def isValid( s: str) -> bool:
    stack=[]
    rel={'(':')','[':']','{':'}'}
    if s[0] in  ['{','(','[']:
        return False
    for item in s:
        if item in ['(','[','{']:
            stack.append(item)
            print("stack" ,stack)
        if item in ['}',')',']']:
            pop = stack.pop()
            print("pop",pop)
            if rel[pop] != item:
                return False
    return True



